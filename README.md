# Bug-Driven Development

Welcome to **Bug-Driven Development**, a hapless (but intentional) experiment in writing code where the methods may be amateurishly unconventional — but they mostly work.

Most of the code here is likely **AI-generated (for better or worse)**, because that’s the only way I know how to get anything running. I am untrained but undeterred — I enjoy experimenting, tinkering, and occasionally stumbling onto something useful. This is not a portfolio, and I’m not looking to start a new career in software engineering. It’s just a sandbox for learning, automation experiments, and digital assistant prototypes.

This repository is my playground for small automation projects duct-taped together with JavaScript and other languages. There are no guarantees here — except that things will probably break, usually in interesting ways.

If you’re looking for best practices, you’re in the wrong place. If you’re looking for trial-and-error chaos that *occasionally* produces something useful, then you’ve found home.

**Core principles of Bug-Driven Development™:**
- Unconventional code that mostly works is still a win.
- Debugging counts as “forward motion.”
- `console.log` is a legitimate engineering tool.
- Shipping > knowing what I’m doing.

Pull requests welcome — especially if they save me from myself.

---

## Getting Started

1. Clone the repo (if you dare).
   ```bash
   git clone https://github.com/yourusername/bug-driven-development.git
   ```  

2. Install the dependencies (there may or may not be any).
   ```bash
   npm install
   ```  

3. Run it and hope for the best:
   ```bash
   node index.js
   ```  

4. When it breaks (and it will), try step 3 again — sometimes persistence works.

5. If all else fails, add a `console.log` somewhere and declare victory.

---

## Roadmap

- [ ] Step 1: Make it work (accidentally).
- [ ] Step 2: Pretend it was intentional.
- [ ] Step 3: Add features that are too complicated.
- [ ] Step 4: Break everything.
- [ ] Step 5: Patch it with a hack found on Stack Overflow or refactor with AI.
- [ ] Step 6: Deploy to production anyway.
- [ ] Step 7: Call it “stable.”
- [ ] Step 8: Rewrite or extend it to incorporate another hairbrained idea.
- [ ] Step 9: Realize way too much time has been spend on this thing.
- [ ] Step 10: Start another project.

---

## Contributing

Here’s the truth: I don’t really know what I’m doing. Most of what you’ll see here is glued together with AI outputs, trial and error, and sheer stubbornness.

That said, I would absolutely welcome help from anyone who *does* know what they’re doing. Professional contributions could transform these personal experiments into something safer, more stable, and maybe even useful for others. If you’re a real developer, your expertise would not only improve the code — it might also save me from myself.

So if you see something here worth fixing, improving, or expanding, please contribute. Any help is genuinely appreciated, and will only make this mess better.
